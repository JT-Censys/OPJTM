/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

// Object.defineProperty alias
const defineProperty = Object.defineProperty;
// Object.getOwnPropertyDescriptor alias
const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// Object.getOwnPropertyNames alias
const getOwnPropertyNames = Object.getOwnPropertyNames;
// Object.prototype.hasOwnProperty alias
const hasOwnProperty = Object.prototype.hasOwnProperty;
// Template Description To Add To New Tickets
const JIRA_DESCRIPTION_TEMPLATE = `Goals\n\nCompleted Steps\n\nCurrent Step\n\n=== Begin Project ===\n`;

// Helper function to define properties on an object
const defineProperties = (object, properties) => {
  for (const property in properties) {
    defineProperty(object, property, {
      get: properties[property],
      enumerable: true,
    });
  }
};

// Helper function to copy properties from one object to another
const copyProperties = (target, source, excludedProperty, descriptor) => {
  if (source && typeof source == "object" || typeof source == "function") {
    for (let property of getOwnPropertyNames(source)) {
      if (!hasOwnProperty.call(target, property) && property !== excludedProperty) {
        defineProperty(target, property, {
          get: () => source[property],
          enumerable: !(descriptor = getOwnPropertyDescriptor(source, property)) || descriptor.enumerable,
        });
      }
    }
  }
  return target;
};

// Helper function to merge objects with __esModule property
const mergeWithModule = (object) => copyProperties(defineProperty({}, "__esModule", { value: true }), object);

// Main plugin object
const plugin = {};
defineProperties(plugin, {
  default: () => JiraPlugin,
});
module.exports = mergeWithModule(plugin);

// Import Obsidian library
const obsidian = require("obsidian");

// Arrays used for project and issue type data
let projectArray =[];
let issueTypeArray =[];

// Main plugin class
const JiraPlugin = class extends obsidian.Plugin {
  // Inside JiraPlugin class
  async getActiveSprintId(boardId) {
    if (!boardId || !this.settings.jiraUrl || !this.settings.username || !this.settings.apiToken) {
        return null;
    }
    try {
        // Note: This uses the Jira Agile API endpoint
        const response = await requestUrl({
            url: `${this.settings.jiraUrl}/rest/agile/1.0/board/${boardId}/sprint?state=active`,
            method: 'GET',
            headers: {
                'Authorization': `Basic ${btoa(`${this.settings.username}:${this.settings.apiToken}`)}`,
                'Content-Type': 'application/json',
                'Origin': this.settings.jiraUrl,
            },
        });
        if (response.json.values && response.json.values.length > 0) {
            // Assuming you want the first active sprint if multiple exist
            return response.json.values[0].id;
        }
        return null;
    } catch (error) {
        console.error(`Error fetching active sprint for board ${boardId}:`, error);
        new Notice(`Failed to fetch active sprint. Check board ID (${boardId}) and permissions.`);
        return null;
    }
  }

  // Inside JiraPlugin class
  async addIssueToKanbanBoard(issueKey, boardId) {
    if (!issueKey || !boardId) {
        console.warn("Missing issueKey or boardId for addIssueToKanbanBoard");
        return false;
    }
    if (!this.settings.jiraUrl || !this.settings.username || !this.settings.apiToken) {
        new Notice("Jira settings (URL, Username, Token) are not configured.");
        return false;
    }
    try {
        await requestUrl({
            url: `${this.settings.jiraUrl}/rest/agile/1.0/board/${boardId}/issue`,
            method: 'POST',
            headers: {
                'Authorization': `Basic ${btoa(`${this.settings.username}:${this.settings.apiToken}`)}`,
                'Content-Type': 'application/json',
                'Origin': this.settings.jiraUrl,
            },
            body: JSON.stringify({
                issues: [issueKey]
                // Jira might support ranking parameters here if you want to place it specifically
                // e.g., "rankToTop": true or similar, but the basic API just takes issue keys.
            }),
        });
        // Don't show notice here, let the calling function compose the final notice
        return true;
    } catch (error) {
        console.error(`Error moving issue ${issueKey} to board ${boardId}:`, error);
        let errorMsg = `Failed to move issue ${issueKey} to board ${boardId}.`;
        if (error.status && error.json && error.json.errorMessages && error.json.errorMessages.length > 0) {
            errorMsg += ` Jira: ${error.json.errorMessages.join(', ')}`;
        } else if (error.message) {
            errorMsg += ` ${error.message}`; // Add specific error message
        } else {
            errorMsg += ` Status: ${error.status || 'Unknown'}.`;
        }
        new Notice(errorMsg);
        return false;
    }
  }

  async getCurrentUserAccountId() {
      if (!this.settings.jiraUrl || !this.settings.username || !this.settings.apiToken) {
          // Notice is optional here, or could be logged, as the main function will also check settings.
          // console.warn("Jira settings are not fully configured to fetch current user.");
          return null;
      }
      try {
          const response = await requestUrl({
              url: `${this.settings.jiraUrl}/rest/api/2/myself`, // Jira API endpoint to get current user details
              method: 'GET',
              headers: {
                  'Authorization': `Basic ${btoa(`${this.settings.username}:${this.settings.apiToken}`)}`,
                  'Content-Type': 'application/json',
                  'Origin': this.settings.jiraUrl,
              },
          });
          if (response.json && response.json.accountId) {
              return response.json.accountId;
          } else {
              new Notice("Could not retrieve your Jira accountId from API response.");
              console.error("Jira /myself response did not contain accountId:", response.json);
              return null;
          }
      } catch (error) {
          console.error("Error fetching current user's accountId:", error);
          new Notice("Failed to fetch your Jira account ID. Cannot auto-assign issue.");
          return null;
      }
  }

  // Inside JiraPlugin class
  async createTheIssueInJira(userProvidedSummary, selectedProject, selectedIssueType, selectedEpicKey, addToBoard, assignToMe) {
    console.log(`CMD: createTheIssueInJira called with summary: ${userProvidedSummary}`);
    try {
        // Settings check still good here
        if (!this.settings.apiToken || !this.settings.jiraUrl || !this.settings.username) {
            new Notice('Jira settings are missing.'); return null;
        }

        // Description is now just the template
        const fullDescription = JIRA_DESCRIPTION_TEMPLATE;

        const fields = {
            summary: userProvidedSummary, // Use the summary from the prompt
            description: markdownToJiraMarkup(fullDescription.trim()),
            project: { key: selectedProject },
            issuetype: { name: selectedIssueType },
            // Priority, DueDate, StoryPoints are NOT set here in this new workflow.
            // They will be populated by openIssueModal from Jira's defaults or what's set in Jira.
        };

        // Epic Link / Parent field handling (same as before)
        if (selectedEpicKey && this.settings.epicLinkFieldId) {
            const epicSetting = this.settings.epicLinkFieldId.toLowerCase().trim();
            if (epicSetting === "parent") fields.parent = { key: selectedEpicKey };
            else if (epicSetting) fields[this.settings.epicLinkFieldId.trim()] = selectedEpicKey;
        }

        // Assign to self (same as before)
        if (assignToMe) {
            const currentUserAccountId = await this.getCurrentUserAccountId();
            if (currentUserAccountId) fields.assignee = { accountId: currentUserAccountId };
            else { /* Notice about not being able to fetch accountId */ }
        }

        // --- Create the issue ---
        const issueCreateResponse = await requestUrl({
            url: `${this.settings.jiraUrl}/rest/api/2/issue/`,
            method: 'post',
            headers: {
              'Authorization': `Basic ${btoa(`${this.settings.username}:${this.settings.apiToken}`)}`,
              'Content-Type': 'application/json',
              'Origin': this.settings.jiraUrl, // Temporarily comment this out
          },
            body: JSON.stringify({ fields: fields }),
        });

        const newIssueKey = issueCreateResponse.json.key;
        console.log(`CMD: Jira issue ${newIssueKey} created via API.`);

        let noticeMessage = `Issue ${newIssueKey} created successfully`;
        if (assignToMe && fields.assignee) noticeMessage += " and assigned to you";

        // Move to Kanban board if selected (same as before, ensure addIssueToKanbanBoard exists)
        if (addToBoard) {
            if (this.settings.jiraBoardId) {
                const moved = await this.addIssueToKanbanBoard(newIssueKey, this.settings.jiraBoardId);
                if (moved) noticeMessage += `. Moved to board ${this.settings.jiraBoardId}`;
                else noticeMessage += `. Failed to move to board ${this.settings.jiraBoardId}`;
            } else {
                noticeMessage += ". Board ID not configured to move issue.";
                new Notice("Default Jira Board ID not configured. Issue not moved to board.");
            }
        }
        new Notice(noticeMessage + ".");

        return newIssueKey; // *** RETURN THE NEW ISSUE KEY ***

    } catch (error) {
        let errorDetails = error.message || 'Unknown error';
        if (error.status) errorDetails += ` (Status: ${error.status})`;
        if (error.json && error.json.errorMessages) errorDetails += ` Jira: ${error.json.errorMessages.join(', ')}`;
        new Notice(`Error during Jira issue creation: ${errorDetails}`);
        console.error("Error in createTheIssueInJira (New Workflow):", error);
        return null; // Return null on failure
    }
  }
  // Method called when the plugin is loaded
  async onload() {
    await this.loadSettings();

    // Add ribbon icon to import issues from Jira
    this.addRibbonIcon("file-down", "Import issue from Jira", (event) => {
        this.openIssueModal();
      });

      // Add command to update issue in Jira
      this.addCommand({
        id: 'update-issue-jira',
        name: 'Update issue to Jira',
        callback: async () => {
            try {
                if (this.settings.apiToken && this.settings.jiraUrl) {
                    let activeFile = this.app.workspace.getActiveFile();
                    let issueKey = '';
                    let summary = '';
                    let priority = '';
                    let dueDate = '';
                    let storyPoints = '';

                    if (activeFile) {
                        await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
                            issueKey = frontmatter.key;
                            summary = frontmatter.summary;
                            if (frontmatter.priority) {
                                priority = frontmatter.priority.charAt(0).toUpperCase() + frontmatter.priority.slice(1).toLowerCase();
                            }
                            dueDate = frontmatter.dueDate;
                            storyPoints = frontmatter.storyPoints;
                        }).then(async () => {
                        let markdownView = this.app.workspace.getActiveViewOfType(obsidian.MarkdownView);
                        let noteContent = markdownView?.getViewData().replace(/---.*?---/gs, '').trim() || '';
                        let updateFields = {
                            description: markdownToJiraMarkup(noteContent || ''),
                            summary: summary,
                            priority: priority ? { name: priority } : undefined,
                            // duedate: dueDate, // Standard duedate field might be different
                        };

                        // *** MODIFIED: Use settings for Due Date ***
                        if (dueDate && this.settings.dueDateFieldId) {
                            updateFields[this.settings.dueDateFieldId] = dueDate;
                        } else if (dueDate && !this.settings.dueDateFieldId) {
                            // If dueDate exists but ID is not set, you might want to notify the user or skip.
                            // For now, it just won't be sent if ID is missing.
                        }


                        // *** MODIFIED: Use settings for Story Points ***
                        if (storyPoints !== undefined && storyPoints !== null && storyPoints !== '' && this.settings.storyPointsFieldId) {
                            const numericStoryPoints = parseFloat(storyPoints);
                            if (!isNaN(numericStoryPoints)) {
                                updateFields[this.settings.storyPointsFieldId] = numericStoryPoints;
                            } else {
                                new Notice(`Story Points value "${storyPoints}" for update is not a valid number. Not sending.`);
                            }
                        }

                        await requestUrl({
                          url: `${this.settings.jiraUrl}/rest/api/2/issue/${issueKey}`,
                          method: 'put',
                          headers: {
                              'Authorization': `Basic ${btoa(`${this.settings.username}:${this.settings.apiToken}`)}`,
                              'Content-Type': 'application/json',
                              'Origin': this.settings.jiraUrl,
                          },
                          body: JSON.stringify({ fields: updateFields }),
                      });

                        new Notice('Issue updated successfully');
                      });
                    } else {
                        new Notice('No active file');
                    }
                } else {
                    new Notice('Please configure Jira API Token and URL in plugin settings');
                }
            } catch (error) {
                new Notice('Error updating issue');
                console.error(error);
            }
        },
    });

      // Add command to get issue from Jira
      this.addCommand({
        id: "get-issue-jira",
        name: "Get issue from Jira",
        callback: async () => {
          this.openIssueModal();
        },
      });

      this.addCommand({
        id: "update-issue-status-jira",
        name: "Update Jira Issue Status",
        callback: async () => {
            this.openStatusUpdateModal(); // We'll create this function
        },
      });
      
      // Inside JiraPlugin class, within onload()

      this.addCommand({
        id: 'view-add-jira-comments',
        name: 'View/Add Jira Comments (from active file)',
        callback: async () => {
            const activeFile = this.app.workspace.getActiveFile();
            if (!activeFile) {
                new obsidian.Notice('No active file to get Jira key from.');
                return;
            }

            let issueKey = '';
            // Ensure frontmatter processing completes.
            // Assuming app.fileManager.processFrontMatter either is awaitable
            // or you handle its asynchronous nature correctly if it uses callbacks.
            // If it's purely synchronous through the callback, the current structure is fine.
            await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
                issueKey = frontmatter.key;
            });

            if (issueKey && this.settings.apiToken && this.settings.jiraUrl && this.settings.username) {
                // *** MODIFICATION HERE: Pass activeFile.path ***
                new JiraCommentsModal(this.app, this, issueKey, activeFile.path).open();
            } else if (!issueKey) {
                new obsidian.Notice('No "key" found in the frontmatter of the active file.');
            } else {
                new obsidian.Notice('Please configure Jira API Token, URL, and Username in plugin settings.');
            }
        },
      });

      // Add command to create issue in Jira
      this.addCommand({
        id: 'create-issue-jira',
        name: 'Create issue in Jira',
        // Inside your JiraPlugin class, for the 'create-issue-jira' command's callback:
        callback: async () => {
          console.log("CMD: 'Create issue in Jira' triggered (New Workflow).");
          try {
              if (!this.settings.apiToken || !this.settings.jiraUrl || !this.settings.username) {
                  console.log("CMD: Settings check FAILED.");
                  new Notice('Please configure Jira API Token, URL, and Username in plugin settings.');
                  return;
              }
              console.log("CMD: Settings check PASSED.");

              new SummaryPromptModal(this.app, async (userProvidedSummary) => {
                  console.log(`CMD: User provided summary: '${userProvidedSummary}'`);

                  let loadingNotice; // Declare here to use in finally block
                  try {
                      console.log("CMD: Attempting to fetch projects from Jira...");
                      loadingNotice = new Notice("Fetching Jira projects...", 0); // 0 makes it persistent

                      const projectResponse = await requestUrl({
                          url: `${this.settings.jiraUrl}/rest/api/2/project`,
                          method: 'get',
                          headers: {
                              'Authorization': `Basic ${btoa(`${this.settings.username}:${this.settings.apiToken}`)}`,
                              'Content-Type': 'application/json',
                          },
                      });
                      loadingNotice.hide(); // Hide after request is done

                      console.log("CMD: Jira API response for projects:", projectResponse);
                      if (projectResponse.status === 200 && projectResponse.json && Array.isArray(projectResponse.json)) {
                          projectArray = projectResponse.json.map((project) => ({
                              id: project.key,
                              name: project.name,
                          }));
                          console.log("CMD: Projects fetched and mapped:", projectArray);
                          if (projectArray.length === 0) {
                              new Notice("No projects found in your Jira instance or none accessible.");
                              console.warn("CMD: projectArray is empty after fetching projects.");
                              return;
                          }
                      } else {
                          const errorMsg = `Failed to fetch projects. Status: ${projectResponse.status}.`;
                          console.error(errorMsg, "Full response:", projectResponse.json);
                          new Notice(errorMsg + " Check console.");
                          return;
                      }
                  } catch (error) {
                      if (loadingNotice) loadingNotice.hide(); // Ensure notice is hidden on error too
                      console.error("CMD: Error during requestUrl for fetching projects:", error);
                      new Notice('Error fetching projects from Jira. Check console.');
                      return;
                  }

                  console.log("CMD: Opening ProjectSelectionModal...");
                  new ProjectSelectionModal(this.app, async (selectedProjectKey) => {
                      console.log(`CMD: Project selected: ${selectedProjectKey}. Fetching issue types...`);
                      let loadingIssueTypesNotice;
                      try {
                          loadingIssueTypesNotice = new Notice(`Workspaceing issue types for ${selectedProjectKey}...`, 0); // Persistent

                          const response = await requestUrl({
                              url: `${this.settings.jiraUrl}/rest/api/2/issue/createmeta/${selectedProjectKey}/issuetypes`,
                              method: 'get',
                              headers: {
                                  'Authorization': `Basic ${btoa(`${this.settings.username}:${this.settings.apiToken}`)}`,
                                  'Content-Type': 'application/json',
                              },
                          });
                          loadingIssueTypesNotice.hide();

                          console.log("CMD: Jira API response for createmeta/issuetypes:", response);
                          if (response.status === 200 && response.json && response.json.issueTypes && Array.isArray(response.json.issueTypes)) {
                              issueTypeArray = response.json.issueTypes.map((issueType) => ({
                                  name: issueType.name,
                                  id: issueType.id,
                              }));
                              console.log("CMD: Successfully populated issueTypeArray:", issueTypeArray);
                              if (issueTypeArray.length === 0) {
                                  new Notice(`No issue types found for project ${selectedProjectKey} (Jira returned an empty list).`);
                                  // No return here, IssueTypeSelectionModal will show "No results found"
                              }
                          } else {
                              issueTypeArray = [];
                              let detail = `Status: ${response.status}.`;
                              if (response.json && !response.json.issueTypes) detail += " 'issueTypes' array missing.";
                              else if (response.json && !Array.isArray(response.json.issueTypes)) detail += " 'issueTypes' not an array.";
                              const errorMessage = `Failed to parse issue types for project ${selectedProjectKey}. ${detail}`;
                              console.error(errorMessage, "Full response:", response.json);
                              new Notice(errorMessage + " Check console.");
                          }
                      } catch (error) {
                          if (loadingIssueTypesNotice) loadingIssueTypesNotice.hide();
                          issueTypeArray = [];
                          console.error(`CMD: Error fetching issue types for project ${selectedProjectKey}:`, error);
                          new Notice(`Error fetching issue types for project ${selectedProjectKey}. See console.`);
                      }

                      // If issueTypeArray is empty here, IssueTypeSelectionModal will show "No results found"
                      // which is acceptable behavior.
                      
                      console.log("CMD: Opening IssueTypeSelectionModal...");
                      new IssueTypeSelectionModal(this.app, async (selectedIssueType) => { // Pass 'this' (plugin) if modal needs it
                          const issueTypeName = typeof selectedIssueType === 'object' ? selectedIssueType.name : selectedIssueType;
                          console.log(`CMD: Issue Type selected: ${issueTypeName}`);

                          let selectedEpicKeyForNextStep = null;

                          const finalSubmitCallback = async (addToBoard, assignToMe) => {
                            const newIssueKey = await this.createTheIssueInJira(
                                userProvidedSummary,
                                selectedProjectKey,
                                issueTypeName,
                                selectedEpicKeyForNextStep, // This should be correctly passed down
                                addToBoard,
                                assignToMe
                            );
    
                            if (newIssueKey) { // Check if a key was successfully returned
                                console.log(`CMD: Issue ${newIssueKey} created. Now fetching it into Obsidian via openIssueModal...`);
                                await this.openIssueModal(newIssueKey); // Call with the new key
                            } else {
                                console.log("CMD: Issue creation failed or no key returned. Skipping fetch to Obsidian.");
                                // A notice about the creation failure would have already been shown in createTheIssueInJira
                            }
                        };

                          if (this.settings.epicLinkFieldId) {
                              console.log("CMD: Epic Link Field ID is configured. Opening EpicSelectionModal...");
                              new EpicSelectionModal(this.app, this, selectedProjectKey, async (selectedEpicKey) => {
                                  selectedEpicKeyForNextStep = selectedEpicKey;
                                  console.log(`CMD: Epic selected: ${selectedEpicKeyForNextStep}. Opening FinalCreateOptionsModal...`);
                                  new FinalCreateOptionsModal(this.app, this, finalSubmitCallback).open();
                              }).open();
                          } else {
                              console.log("CMD: Epic Link Field ID NOT configured. Opening FinalCreateOptionsModal directly...");
                              new FinalCreateOptionsModal(this.app, this, finalSubmitCallback).open();
                          }
                      }).open();
                  }).open();
              }).open(); // This .open() is for SummaryPromptModal

          } catch (error) {
              console.error("CMD: A critical error occurred in 'create-issue-jira' command (New Workflow):", error);
              new Notice('An unexpected error occurred. Check the developer console.');
          }
        },
    });

      // Add settings tab to Obsidian settings
      this.addSettingTab(new JiraSettingTab(this.app, this));
    }

    // Method called when the plugin is unloaded
    onunload() {}

    // Method to load plugin settings
    async loadSettings() {
      this.settings = Object.assign(
          {
              apiToken: "",
              jiraUrl: "",
              username: "",
              epicLinkFieldId: "",    // From previous change
              sprintFieldId: "",      // From previous change
              jiraBoardId: "",        // From previous change
              dueDateFieldId: "",     // *** NEW ***
              storyPointsFieldId: ""  // *** NEW ***
          },
          await this.loadData()
      );
  }

    // Method to save plugin settings
    async saveSettings() {
      await this.saveData(this.settings);
    }
    
    async openStatusUpdateModal() {
      new IssueKeyModal(this.app, async (issueKey) => {
          try {
              if (this.settings.username && this.settings.apiToken && this.settings.jiraUrl) {
                  // 1. Get available transitions from Jira API
                  const transitions = await this.getJiraIssueTransitions(issueKey);
                  if (transitions && transitions.length > 0) {
                      // 2. Open the status update modal
                      new JiraStatusUpdateModal(this.app, issueKey, transitions, async (transitionId) => {
                          // 3. Perform the transition using Jira API
                          await this.performJiraIssueTransition(issueKey, transitionId);
                          new obsidian.Notice("Jira issue status updated successfully.");
                      }).open();
                  } else {
                      new obsidian.Notice("No transitions available for this issue.");
                  }
              } else {
                  new obsidian.Notice("Please configure Jira settings.");
              }
          } catch (error) {
              new obsidian.Notice("Error updating Jira issue status.");
              console.error(error);
          }
      }).open();
  }

  async getJiraIssueTransitions(issueKey) {
      try {
          const response = await (0, obsidian.requestUrl)({
              url: `${this.settings.jiraUrl}/rest/api/2/issue/${issueKey}/transitions`,
              method: "GET",
              headers: {
                  "Authorization": `Basic ${btoa(
                      `${this.settings.username}:${this.settings.apiToken}`
                  )}`,
                  "Content-Type": "application/json",
                  "Origin": this.settings.jiraUrl,
              },
          });
          if (response.status === 200) {
              const data = response.json;
              return data.transitions.map((transition) => ({
                  id: transition.id,
                  name: transition.name,
              }));
          } else {
              console.error("Error fetching transitions:", response);
              return null;
          }
      } catch (error) {
          console.error("Error fetching transitions:", error);
          return null;
      }
  }
  async performJiraIssueTransition(issueKey, transitionId) {
    try {
        const response = await (0, obsidian.requestUrl)({
            url: `${this.settings.jiraUrl}/rest/api/2/issue/${issueKey}/transitions`,
            method: "POST",
            headers: {
                "Authorization": `Basic ${btoa(
                    `${this.settings.username}:${this.settings.apiToken}`
                )}`,
                "Content-Type": "application/json",
                "Origin": this.settings.jiraUrl,
            },
            body: JSON.stringify({
                transition: {
                    id: transitionId,
                },
            }),
        });
        // Log the successful response for debugging
        //console.log("Jira API Response:", response);
        if (response.status === 204) {
            return true; // Transition successful
        } else {
             // Log the entire response for debugging
            console.error("Jira API Response:", response);
            // Optionally, you can try to parse the JSON body for a more specific error message
            try {
                const errorBody = await response.json();
                console.error("Jira API Error Details:", errorBody);
            } catch (jsonError) {
                console.error("Error parsing JSON error response:", jsonError);
            }
            return false;
        }
    } catch (error) {
        // Log the error object
        console.error("Error performing transition:", error);
         if (error.status) {
             console.error("HTTP Status Code:", error.status);
         }
         if (error.message) {
             console.error("Error Message:", error.message);
         }
        return false;
    }
  }

  // Method to open the issue retrieval modal
  async openIssueModal(issueKeyFromCreation = null) { // Added optional parameter
      const processIssue = async (issueKeyToProcess) => {
          if (!issueKeyToProcess || issueKeyToProcess.trim() === "") {
              new Notice("Issue key cannot be empty.");
              return;
          }
          try {
              if (!this.settings.apiToken || !this.settings.jiraUrl || !this.settings.username) {
                  new Notice('Please configure Jira API Token, URL, and Username in plugin settings.');
                  return;
              }
              console.log(`CMD: openIssueModal - Processing issue: ${issueKeyToProcess}`);

              const issueResponse = await requestUrl({
                  // Expand parent to get Epic details if linked via parent field
                  url: `${this.settings.jiraUrl}/rest/api/2/issue/${issueKeyToProcess}?expand=parent`,
                  headers: {
                      'Authorization': `Basic ${btoa(`${this.settings.username}:${this.settings.apiToken}`)}`,
                      'Content-Type': 'application/json',
                  },
              });
              const issueData = issueResponse.json;
              console.log(`CMD: openIssueModal - Fetched data for ${issueKeyToProcess}:`, issueData);


              let jiraIssuesFolder = await this.app.vault.getAbstractFileByPath('jira-issues');
              if (!jiraIssuesFolder) {
                  await this.app.vault.createFolder('jira-issues');
              }

              // Sanitize summary for filename (basic sanitization)
              const sanitizedSummary = issueData.fields.summary.replace(/[\\/:*?"<>|]/g, '_').substring(0, 100);
              const filePath = `jira-issues/${sanitizedSummary}.md`;

              // Prepare frontmatter
              const frontmatterObject = {
                  key: issueKeyToProcess,
                  summary: issueData.fields.summary,
              };
              if (issueData.fields.priority) frontmatterObject.priority = issueData.fields.priority.name;
              if (issueData.fields.status) frontmatterObject.status = issueData.fields.status.name;
              if (this.settings.dueDateFieldId && issueData.fields[this.settings.dueDateFieldId]) {
                  frontmatterObject.dueDate = issueData.fields[this.settings.dueDateFieldId];
              }
              if (this.settings.storyPointsFieldId && issueData.fields[this.settings.storyPointsFieldId] !== undefined) {
                  frontmatterObject.storyPoints = issueData.fields[this.settings.storyPointsFieldId];
              }

              // Epic Link/Parent
              const parentFieldData = issueData.fields.parent;
              const epicLinkSettingValue = this.settings.epicLinkFieldId ? this.settings.epicLinkFieldId.toLowerCase().trim() : "";
              if (parentFieldData && parentFieldData.fields && parentFieldData.fields.issuetype && parentFieldData.fields.issuetype.name === "Epic") {
                  frontmatterObject.epicKey = parentFieldData.key;
                  frontmatterObject.epicSummary = parentFieldData.fields.summary;
              } else if (epicLinkSettingValue && epicLinkSettingValue !== "parent" && issueData.fields[this.settings.epicLinkFieldId]) {
                  frontmatterObject.epicKey = issueData.fields[this.settings.epicLinkFieldId];
              }

              // Prepare description
              let descriptionContent = "";
              if (issueData.fields.description !== null && issueData.fields.description !== undefined) {
                  descriptionContent = jiraMarkupToMarkdown(issueData.fields.description); // Assuming jiraMarkupToMarkdown is available
              }

              // Construct full file content
              let yamlFrontmatter = "---\n";
              for (const key in frontmatterObject) {
                  if (frontmatterObject[key] !== undefined) {
                      // Simple stringification for YAML, ensure proper formatting for complex strings if needed
                      let value = frontmatterObject[key];
                      if (typeof value === 'string') {
                          // Basic handling for strings that might contain colons or need quotes
                          if (value.includes(':') || value.includes('"') || value.includes("'")) {
                              value = JSON.stringify(value);
                          } else if (value.trim() === "" && key === "summary") { // Handle empty summary just in case
                              value = "Untitled Jira Issue";
                          }
                      }
                      yamlFrontmatter += `${key}: ${value}\n`;
                  }
              }
              yamlFrontmatter += "---\n\n";
              const finalFileContent = yamlFrontmatter + descriptionContent;

              // Create or overwrite the file
              const targetFile = await this.app.vault.create(filePath, finalFileContent, { overwrite: true });
              console.log(`CMD: openIssueModal - Created/Updated file: ${filePath}`);

              // Open the file
              await this.app.workspace.openLinkText(filePath, '', false); // false for 'newLeaf' if you want to open in current leaf

          } catch (error) {
              let errorMessage = `Error processing issue ${issueKeyToProcess}`;
              if (error.status) errorMessage += ` (HTTP ${error.status})`;
              if (error.json && error.json.errorMessages) errorMessage += `: ${error.json.errorMessages.join(', ')}`;
              else if (error.message) errorMessage += `: ${error.message}`;
              new Notice(errorMessage);
              console.error(`CMD: openIssueModal - Error processing issue ${issueKeyToProcess}:`, error);
          }
      };

      if (issueKeyFromCreation) {
          // If an issue key is provided (e.g., from the creation process), process it directly
          console.log(`CMD: openIssueModal called with key: ${issueKeyFromCreation}. Processing directly.`);
          await processIssue(issueKeyFromCreation);
      } else {
          // Otherwise, open the modal to ask for the key (original behavior for manual import)
          console.log("CMD: openIssueModal called without key. Opening IssueKeyModal.");
          new IssueKeyModal(this.app, async (keyFromModal) => {
              await processIssue(keyFromModal);
          }).open();
      }
  }
};

// Modal to search for an issue by key
const IssueKeyModal = class extends obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.setTitle("Search issue for key");
    this.onSubmit = onSubmit;
    let key = "";
    new obsidian.Setting(this.contentEl)
      .setName("Key")
      .addText((text) =>
        text.onChange((value) => {
          key = value;
        })
      );
    new obsidian.Setting(this.contentEl).addButton((button) =>
      button
        .setButtonText("Search")
        .setCta()
        .onClick(() => {
          this.close();
          onSubmit(key);
        })
    );
    this.contentEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        onSubmit(key);
        this.close();
      }
    });
  }
};

// Modal for suggesting and selecting a project
const ProjectSelectionModal = class extends obsidian.SuggestModal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  getSuggestions(query){
    return projectArray.filter(
      (project) =>
        project.id.toLowerCase().includes(query.toLowerCase()) ||
        project.name.toLowerCase().includes(query.toLowerCase())
    );
  }
  renderSuggestion(project, el) {
    el.createEl("div", { text: project.name });
    el.createEl("small", { text: project.id });
  }
  async onChooseSuggestion(project, evt) {
    this.onSubmit(project.id);
  }
};

// Modal for suggesting and selecting an issue type
const IssueTypeSelectionModal = class extends obsidian.SuggestModal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  renderSuggestion(issueType, el) {
    el.createEl("div", { text: issueType.name });
  }
  getSuggestions(query) {
    return issueTypeArray.filter((issueType) => issueType.name.toLowerCase().includes(query.toLowerCase()));
  }
  async onChooseSuggestion(issueType, evt) {
    this.onSubmit(issueType.name);
  }
};

class JiraStatusUpdateModal extends obsidian.Modal {
  constructor(app, issueKey, transitions, onSubmit) {
      super(app);
      this.issueKey = issueKey;
      this.transitions = transitions;
      this.onSubmit = onSubmit;
      this.setTitle("Update Issue Status");
  }
  onOpen() {
      const { contentEl } = this;
      contentEl.createEl("h2", { text: `Update Status for ${this.issueKey}` });
      // Create a dropdown/select element
      const statusSelect = contentEl.createEl("select");
      this.transitions.forEach((transition) => {
          const option = statusSelect.createEl("option", {
              text: transition.name,
              value: transition.id,
          });
      });
      // Add a button to submit the status change
      const updateButton = contentEl.createEl("button", { text: "Update Status" });
      updateButton.addEventListener("click", () => {
          const selectedTransitionId = statusSelect.value;
          this.onSubmit(selectedTransitionId);
          this.close();
      });
  }
  onClose() {
      // Clean up modal elements, if necessary
  }
  
}

// (Add this class definition with your other modals in main.js)
class SummaryPromptModal extends obsidian.Modal {
  constructor(app, onSubmit) {
      super(app);
      this.onSubmit = onSubmit; // Callback function that receives the summary
      this.summaryText = "";   // To store the input
  }

  onOpen() {
      const { contentEl } = this;
      contentEl.empty();
      this.setTitle("Create New Jira Issue");

      contentEl.createEl("h3", { text: "Enter Issue Summary:" });

      const textInput = contentEl.createEl("input", { type: "text" });
      textInput.setAttribute("style", "width: 100%; margin-bottom: 10px;");
      textInput.focus(); // Auto-focus on the input field

      // Handle Enter key
      textInput.addEventListener("keypress", (event) => {
          if (event.key === "Enter") {
              event.preventDefault(); // Prevent default Enter behavior (like form submission)
              this.summaryText = textInput.value.trim();
              if (this.summaryText) {
                  this.close();
                  this.onSubmit(this.summaryText);
              } else {
                  new Notice("Summary cannot be empty.");
              }
          }
      });

      const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
      const submitButton = buttonContainer.createEl("button", {
          text: "Next",
          cls: "mod-cta" // Makes it a prominent button
      });

      submitButton.onClickEvent(() => {
          this.summaryText = textInput.value.trim();
          if (this.summaryText) {
              this.close();
              this.onSubmit(this.summaryText);
          } else {
              new Notice("Summary cannot be empty.");
          }
      });
  }

  onClose() {
      this.contentEl.empty();
  }
}

// (Ensure this class is defined in your main.js)
class FinalCreateOptionsModal extends obsidian.Modal {
  constructor(app, plugin, onSubmit) {
      super(app);
      this.plugin = plugin;
      this.onSubmit = onSubmit;
      this.addToBoard = false; // Renamed from addToSprint
      this.assignToMe = false;
      this.setTitle("Final Options & Create Issue");
  }

  onOpen() {
      const { contentEl } = this;
      contentEl.empty();
      const pluginSettings = this.plugin.settings;

      // "Add to Kanban board" option
      if (pluginSettings && pluginSettings.jiraBoardId) {
          new obsidian.Setting(contentEl)
              .setName(`Add to Kanban board`) // Changed label
              .setDesc(`Board ID: ${pluginSettings.jiraBoardId}. This will attempt to place the issue onto the specified board.`)
              .addToggle(toggle => toggle
                  .setValue(this.addToBoard)
                  .onChange(value => {
                      this.addToBoard = value;
                  }));
      } else {
          contentEl.createEl('p', { text: 'Default Jira Board ID not configured in settings for Kanban board placement.' });
      }

      // "Assign to me" checkbox (remains the same)
      new obsidian.Setting(contentEl)
          .setName("Assign to me")
          .setDesc("Assign the new issue to yourself.")
          .addToggle(toggle => {
              // this.assignToMeToggle = toggle; // Only needed if you have dynamic interaction
              toggle
                  .setValue(this.assignToMe)
                  .onChange(value => this.assignToMe = value);
          });

      new obsidian.Setting(contentEl)
          .addButton(button => button
              .setButtonText("Create Jira Issue")
              .setCta()
              .onClick(() => {
                  this.close();
                  this.onSubmit(this.addToBoard, this.assignToMe); // Pass addToBoard
              }));
  }

  onClose() {
      this.contentEl.empty();
  }
}

// (Define this class similar to other modals in your main.js)
const EpicSelectionModal = class extends obsidian.SuggestModal {
  constructor(app, plugin, projectKey, onSubmit) {
      super(app);
      this.plugin = plugin;
      this.projectKey = projectKey;
      this.onSubmit = onSubmit;
      this.setPlaceholder("Search for an Epic in project " + projectKey + " (or type 'SKIP' to not link)");
  }

  async fetchEpics(query) {
      if (!this.projectKey || !this.plugin.settings.jiraUrl || !this.plugin.settings.username || !this.plugin.settings.apiToken) {
          return [];
      }
      try {
          const jql = `project = "${this.projectKey}" AND issuetype = Epic ${query ? "AND summary ~ '" + query.replace(/"/g, "\\\"") + "*'" : ""} ORDER BY summary ASC`;
          const response = await requestUrl({
              url: `${this.plugin.settings.jiraUrl}/rest/api/2/search`,
              method: 'POST', // Using POST for JQL is often more robust for complex queries
              headers: {
                  'Authorization': `Basic ${btoa(`${this.plugin.settings.username}:${this.plugin.settings.apiToken}`)}`,
                  'Content-Type': 'application/json',
                  'Origin': this.plugin.settings.jiraUrl,
              },
              body: JSON.stringify({
                  jql: jql,
                  fields: ["summary", "key"], // We only need summary and key
                  maxResults: 15 // Limit results for performance
              })
          });
          return response.json.issues.map(issue => ({
              id: issue.key,
              name: issue.fields.summary,
          }));
      } catch (error) {
          console.error("Error fetching epics:", error);
          new Notice("Failed to fetch epics.");
          return [];
      }
  }

  async getSuggestions(query) {
      if (query.toLowerCase() === 'skip') {
          return [{ id: null, name: "Skip Epic Linking" }];
      }
      const epics = await this.fetchEpics(query);
      // Optionally add a "Skip" option if no specific skip query is typed
      if (!query && !epics.find(e => e.id === null)) {
           epics.unshift({ id: null, name: "Skip Epic Linking / No Epic" });
      }
      return epics;
  }

  renderSuggestion(epic, el) {
      el.createEl("div", { text: epic.name });
      if (epic.id) {
          el.createEl("small", { text: epic.id });
      }
  }

  onChooseSuggestion(epic, evt) {
      this.onSubmit(epic.id); // Pass null if "Skip" is chosen
  }
};

// Potentially at the end of the file, with other modal definitions
class JiraCommentsModal extends obsidian.Modal {
  constructor(app, plugin, issueKey, activeFilePath) {
      super(app); // This still correctly calls the Modal constructor
      this.plugin = plugin;
      this.issueKey = issueKey;
      this.activeFilePath = activeFilePath;
      this.setTitle(`Jira Comments for ${this.issueKey}`);
      this.debouncedAddComment = obsidian.debounce(this.addComment.bind(this), 1000, true);

      // Array to manually manage lifecycle of components created for markdown rendering
      this._managedMarkdownRenderChildren = [];
  }

  async onOpen() {
      // For debugging, you can leave these or remove them once confirmed
      // console.log("JiraCommentsModal onOpen: 'this' is", this);
      // console.log("JiraCommentsModal onOpen: 'this' instanceof obsidian.Modal?", this instanceof obsidian.Modal); // Expected: true
      // console.log("JiraCommentsModal onOpen: 'this' instanceof obsidian.Component?", this instanceof obsidian.Component); // Expected: true, but is false for you
      // console.log("JiraCommentsModal onOpen: typeof this.addChild?", typeof this.addChild); // Expected: "function", but is undefined for you

      const { contentEl } = this;
      contentEl.empty();

      this.commentsContainer = contentEl.createEl('div', { cls: 'jira-comments-container' });
      this.commentsContainer.style.maxHeight = '300px';
      this.commentsContainer.style.overflowY = 'auto';
      this.commentsContainer.style.marginBottom = '15px';

      const newCommentDiv = contentEl.createEl('div', { cls: 'jira-new-comment-div' });
      this.newCommentTextarea = newCommentDiv.createEl('textarea', {
          cls: 'jira-new-comment-textarea',
          attr: { placeholder: 'Add a comment...' }
      });
      this.newCommentTextarea.style.width = '100%';
      this.newCommentTextarea.style.minHeight = '80px';

      const addButton = newCommentDiv.createEl('button', { text: 'Add Comment' });
      addButton.addEventListener('click', () => {
          this.debouncedAddComment();
      });

      await this.fetchAndDisplayComments();
  }

  async fetchAndDisplayComments() {
      if (!this.issueKey) return;
      this.commentsContainer.setText('Loading comments...');

      // Clear any previously managed children from a potential prior refresh within the same modal session
      for (const child of this._managedMarkdownRenderChildren) {
          child.unload();
      }
      this._managedMarkdownRenderChildren = [];


      try {
          const response = await obsidian.requestUrl({
              url: `${this.plugin.settings.jiraUrl}/rest/api/2/issue/${this.issueKey}/comment`,
              method: 'GET',
              headers: {
                  'Authorization': `Basic ${btoa(`${this.plugin.settings.username}:${this.plugin.settings.apiToken}`)}`,
                  'Content-Type': 'application/json',
                  'Origin': this.plugin.settings.jiraUrl,
              },
          });

          this.commentsContainer.empty();
          const comments = response.json.comments;

          if (comments && comments.length > 0) {
              for (const comment of comments) {
                  const commentEl = this.commentsContainer.createEl('div', { cls: 'jira-comment' });
                  commentEl.style.border = '1px solid var(--background-modifier-border)';
                  commentEl.style.padding = '10px';
                  commentEl.style.marginBottom = '10px';
                  commentEl.style.borderRadius = 'var(--radius-m)';

                  commentEl.createEl('strong', { text: comment.author.displayName });
                  commentEl.createEl('div', {
                      text: new Date(comment.created).toLocaleString(),
                      cls: 'jira-comment-date',
                      attr: { style: 'font-size: 0.8em; color: var(--text-muted);' }
                  });

                  const formattedBody = jiraMarkupToMarkdown(comment.body);
                  const bodyEl = commentEl.createEl('div', { cls: 'jira-comment-body' });

                  // Create a new Component instance. This should work fine.
                  const markdownRenderChild = new obsidian.Component();
                  // Store it for manual unloading
                  this._managedMarkdownRenderChildren.push(markdownRenderChild);

                  // No this.addChild() as it's not available on 'this' (the modal)

                  await obsidian.MarkdownRenderer.render(
                      this.app,
                      formattedBody,
                      bodyEl,
                      this.activeFilePath,
                      markdownRenderChild // Pass the new, valid Component instance
                  );
              }
          } else {
              this.commentsContainer.setText('No comments yet.');
          }
      } catch (error) {
          console.error('Error fetching Jira comments:', error);
          this.commentsContainer.setText('Failed to load comments.');
          let errorMessage = 'Error fetching comments';
          if (error instanceof Error) {
              errorMessage += `: ${error.message}`;
              if (error.status) {
                   errorMessage += ` (HTTP ${error.status})`;
              }
          } else if (typeof error === 'string') {
               errorMessage += `: ${error}`;
          }
          new obsidian.Notice(errorMessage);
      }
  }

  async addComment() {
      const commentText = this.newCommentTextarea.value.trim();
      if (!commentText) {
          new obsidian.Notice('Comment cannot be empty.');
          return;
      }
      const jiraCommentBody = markdownToJiraMarkup(commentText);
      try {
          await obsidian.requestUrl({
              url: `${this.plugin.settings.jiraUrl}/rest/api/2/issue/${this.issueKey}/comment`,
              method: 'POST',
              headers: {
                  'Authorization': `Basic ${btoa(`${this.plugin.settings.username}:${this.plugin.settings.apiToken}`)}`,
                  'Content-Type': 'application/json',
                  'Origin': this.plugin.settings.jiraUrl,
              },
              body: JSON.stringify({ body: jiraCommentBody }),
          });
          new obsidian.Notice('Comment added successfully to Jira.');
          this.newCommentTextarea.value = '';
          await this.fetchAndDisplayComments(); // Refresh comments list
      } catch (error) {
          console.error('Error adding Jira comment:', error);
          let errorMessage = 'Error adding comment.';
          // ... (error handling as before) ...
          new obsidian.Notice(errorMessage);
      }
  }

  // Override the unload method from Component (which Modal should inherit)
  // to manually unload our child components.
  unload() {
      // Unload manually managed children
      if (this._managedMarkdownRenderChildren) {
          for (const child of this._managedMarkdownRenderChildren) {
              child.unload();
          }
          this._managedMarkdownRenderChildren = []; // Clear the array
      }

      // Call the superclass's unload method.
      // It's important to do this, even if `this instanceof obsidian.Component` is false,
      // `super.unload()` will attempt to call the unload method of the parent class (`obsidian.Modal`).
      // If `obsidian.Modal` itself has an unload method (it should, from its own potential Component base or own logic),
      // it needs to be called.
      // Since we know `this` is an `obsidian.Modal`, `super` refers to `obsidian.Modal.prototype`.
      // If `obsidian.Modal.prototype.unload` exists, it will be called.
      // If it doesn't, and `obsidian.Modal` isn't truly a Component in this env, this might do nothing or error.
      // However, it's the most correct way to try and chain up.
      // Given the weirdness, let's be safe:
      if (super.unload) {
           super.unload();
      }
  }

  // onClose is called before unload.
  // We don't need to do anything special with _managedMarkdownRenderChildren here,
  // as unload() will handle them.
  // onClose() {
  //     super.onClose(); // Good practice to call if overriding
  // }
}

// Settings tab in Obsidian settings
const JiraSettingTab = class extends obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl: container } = this;
    container.empty();

    // Jira Username Setting
    new obsidian.Setting(container)
      .setName("Jira Username")
      .addText((text) => {
        text
          .setPlaceholder("Jira Email")
          .setValue(this.plugin.settings.username)
          .onChange(async (value) => {
            this.plugin.settings.username = value;
            await this.plugin.saveSettings();
          });
      });

    // Jira API Token Setting
    new obsidian.Setting(container)
      .setName("Jira API Token")
      .addText((text) => {
        text.inputEl.type = "password"; // Use password input for security
        text
          .setPlaceholder("Jira API Token")
          .setValue(this.plugin.settings.apiToken)
          .onChange(async (value) => {
            this.plugin.settings.apiToken = value;
            await this.plugin.saveSettings();
          });
      });

    new obsidian.Setting(container)
      .setName("Jira url")
      .addText((text) =>
        text
          .setPlaceholder("Url")
          .setValue(this.plugin.settings.jiraUrl)
          .onChange(async (value) => {
            this.plugin.settings.jiraUrl = value;
            await this.plugin.saveSettings();
          })
      );
    
    new obsidian.Setting(container)
    .setName("Default Jira Board ID")
    .setDesc("The ID of your Jira board for fetching active sprints.")
    .addText((text) =>
        text
            .setPlaceholder("e.g., 123")
            .setValue(this.plugin.settings.jiraBoardId || "")
            .onChange(async (value) => {
                this.plugin.settings.jiraBoardId = value.trim();
                await this.plugin.saveSettings();
            })
    );

    new obsidian.Setting(container)
    .setName("Jira Epic Linking Field")
    .setDesc("Enter the custom field ID for 'Epic Link' (e.g., customfield_10001) OR type the word 'parent' if your Jira uses the standard parent field for Epic linking (common in newer Jira Cloud projects). Leave empty if not used.")
    .addText((text) =>
        text
            .setPlaceholder("e.g., customfield_10001 or parent")
            .setValue(this.plugin.settings.epicLinkFieldId || "")
            .onChange(async (value) => {
                this.plugin.settings.epicLinkFieldId = value.trim();
                await this.plugin.saveSettings();
            })
    );

    new obsidian.Setting(container)
    .setName("Jira Sprint Field ID")
    .setDesc("The custom field ID for 'Sprint' (e.g., customfield_10002).")
    .addText((text) =>
        text
            .setPlaceholder("e.g., customfield_10002")
            .setValue(this.plugin.settings.sprintFieldId || "")
            .onChange(async (value) => {
                this.plugin.settings.sprintFieldId = value.trim();
                await this.plugin.saveSettings();
            })
    );
    
    new obsidian.Setting(container)
    .setName("Jira Due Date Field ID")
    .setDesc("The custom field ID for 'Due Date' (e.g., customfield_10241). Leave empty if not used.")
    .addText((text) =>
        text
            .setPlaceholder("e.g., customfield_10241")
            .setValue(this.plugin.settings.dueDateFieldId || "")
            .onChange(async (value) => {
                this.plugin.settings.dueDateFieldId = value.trim();
                await this.plugin.saveSettings();
            })
    );
  
    new obsidian.Setting(container)
        .setName("Jira Story Points Field ID")
        .setDesc("The custom field ID for 'Story Points' (e.g., customfield_10032). Leave empty if not used.")
        .addText((text) =>
            text
                .setPlaceholder("e.g., customfield_10032")
                .setValue(this.plugin.settings.storyPointsFieldId || "")
                .onChange(async (value) => {
                    this.plugin.settings.storyPointsFieldId = value.trim();
                    await this.plugin.saveSettings();
                })
        );
  }
};

// Function to convert Markdown to Jira markup
function markdownToJiraMarkup(markdown) {
  let replacements = {
    del: "-",
    ins: "+",
    sup: "^",
    sub: "~",
  };
  return markdown
    .replace(
      /^(\|[^\n]+\|\r?\n)((?:\|\s*:?[-]+:?\s*)+\|)(\n(?:\|[^\n]+\|\r?\n?)*)?$/gm,
      (match, header, separator, body) => {
        let headers = header.match(/[^|]+(?=\|)/g) || [];
        let separators = separator.match(/[^|]+(?=\|)/g) || [];
        if (headers.length !== separators.length) {
          return match;
        }
        if (body && body.split(`\n`).length === 2 && headers.length === 1) {
          return `{panel:title=${headers[0].trim()}}
${body.replace(/^\|(.*)[ \t]*\|/, "$1").trim()}
{panel}
`;
        } else {
          return `||${headers.join("||")}||${body}`;
        }
      }
    )
    .replace(/([*_]+)(\S.*?)\1/g, (match, symbols, text) => {
      switch (symbols.length) {
        case 1:
          return `_${text}_`;
        case 2:
          return `*${text}*`;
        case 3:
          return `_*${text}*_`;
        default:
          return symbols + text + symbols;
      }
    })
    .replace(/^([#]+)(.*?)$/gm, (match, hashes, text) => `h${hashes.length}.${text}`)
    .replace(/^(.*?)\n([=-]+)$/gm, (match, text, separator) => `h${separator[0] === "=" ? 1 : 2}.\n${text}`)
    .replace(/^([ \t]*)\d+\.\s+/gm, (match, indentation) => `${Array(Math.floor(indentation.length / 3) + 1).fill("#").join("")} `)
    .replace(/^([ \t]*)\*\s+/gm, (match, indentation) => `${Array(Math.floor(indentation.length / 2 + 1)).fill("*").join("")} `)
    .replace(
      new RegExp(`<(${Object.keys(replacements).join("|")})>(.*?)</\\1>`, "g"),
      (match, tag, text) => {
        let replacement = replacements[tag];
        return replacement + text + replacement;
      }
    )
    .replace(/(\s+)~~(.*?)~~(\s+)/g, "$1-$2-$3")
    .replace(/```(.+\n)?((?:.|\n)*?)```/g, (match, language, code) => {
      let codeBlock = "{code}";
      if (language) {
        codeBlock = `{code:${language.replace(/\n/g, "")}}\n`;
      }
      return `${codeBlock}${code}{code}`;
    })
    .replace(/`([^`]+)`/g, "{{$1}}")
    .replace(/!\[[^\]]*\]\(([^)]+)\)/g, "!$1!")
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, "[$1|$2]")
    .replace(/<([^>]+)>/g, "[$1]")
    .replace(/^>/gm, "bq.");
}

// Function to convert Jira markup to Markdown
function jiraMarkupToMarkdown(markup) {
  return markup
    .replace(/^[ \t]*(\*+)\s+/gm, (match, stars) => `${Array(stars.length).join("  ")}* `)
    .replace(/^[ \t]*(#+)\s+/gm, (match, hashes) => `${Array(hashes.length).join("   ")}1. `)
    .replace(/^h()\.(.*)$/gm, (match, level, text) => Array(parseInt(level, 10) + 1).join("#") + text)
    .replace(/\*(\S.*)\*/g, "**$1**")
    .replace(/_(\S.*)_/g, "*$1*")
    .replace(/\{\{([^}]+)\}\}/g, "`$1`")
    .replace(/\+([^+]*)\+/g, "<ins>$1</ins>")
    .replace(/\^([^^]*)\^/g, "<sup>$1</sup>")
    .replace(/~([^~]*)~/g, "<sub>$1</sub>")
    .replace(/(\s+)-(\S+.*?\S)-(\s+)/g, "$1~~$2~~$3")
    .replace(
      /{code(:([a-z]+))?([:|]?(title|borderStyle|borderColor|borderWidth|bgColor|titleBGColor)=.+?)*\}([^]*?)\n?\{code\}/gm,
      "```$2$5\n```"
    )
    .replace(/{noformat}/g, "```")
    .replace(/\[([^|]+?)\]/g, "<$1>")
    .replace(/!(.+)!/g, "!($1)")
    .replace(/\[(.+?)\|(.+?)\]/g, "[$1]($2)")
    .replace(/^bq\.\s+/gm, "> ")
    .replace(/\{color:[^}]+\}([^]*?)\{color\}/gm, "$1")
    .replace(
      /{panel:title=([^}]*)\}\n?([^]*?)\n?\{panel\}/gm,
      `\n|\n$1 |\n| --- |\n| $2 |\n`
    )
    .replace(/^[ \t]*((?:\|\|.*?)+\|\|)[ \t]*$/gm, (match, row) => {
      let cleanRow = row.replace(/\|\|/g, "|");
      return `${cleanRow}\n${cleanRow.replace(/\|[^|]+/g, "| --- ")}`;
    })
    .replace(/^[ \t]*\|/gm, "|");
}

